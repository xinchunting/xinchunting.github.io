{"meta":{"title":"X x","subtitle":null,"description":null,"author":"xXx","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"spring-boot","slug":"spring-boot","date":"2017-12-05T02:45:03.456Z","updated":"2017-12-05T02:45:03.448Z","comments":true,"path":"2017/12/05/spring-boot/","link":"","permalink":"http://yoursite.com/2017/12/05/spring-boot/","excerpt":"","text":"spring &amp; spring boot 注解汇总 及 说明 xXx @SpringBootApplication:包含@Configuration、@EnableAutoConfiguration、@ComponentScan通常用在主类上。 12345678910/** * quick start */@SpringBootApplicationpublic class Application extends SpringBootServletInitializer&#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; @Repository:用于标注数据访问组件，即DAO组件。 123@Repository public class VentorDaoImpl implements iVentorDao &#123; &#125; @Service:用于标注业务层组件。 12@Servicepublic class SystemUserService &#123;&#125; @RestController:用于标注控制层组件(如struts中的action)，包含@Controller和@ResponseBody。 12@RestControllerpublic class APIUserController &#123;&#125; @ResponseBody：表示该方法的返回结果直接写入HTTP response body中一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。 123456@RequestMapping(value =\"/api\", method = RequestMethod.GET)@ResponseBodypublic String list(SystemUser systemUser) &#123; SystemUser systemUsers = systemUserService.insert(systemUser); return JSON.toJSONString(\"1111\");&#125; @Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 1234@Componentpublic @interface Service &#123; String value() default \"\";&#125; @ComponentScan：不要配置到具体的包上边 那样只是扫描你配置的那个包 其他的包都不会扫描组件扫描。个人理解相当于，如果扫描到有@Component @Controller @Service等这些注解的类，则把这些类注册为bean。 1234567@ComponentScan(value=\"com.kingdom\")@SpringBootApplicationpublic class SpecialtymallApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpecialtymallApplication.class, args); &#125;&#125; @Configuration：指出该类是 Bean 配置的信息源，相当于XML中的，一般加在主类上。 12345678@Configuration@EnableAutoConfiguration@ComponentScanpublic class SpecialtymallApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpecialtymallApplication.class, args); &#125;&#125; @Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。 @EnableAutoConfiguration：让 Spring Boot 根据应用所声明的依赖来对 Spring 框架进行自动配置，一般加在主类上。 12345678@Configuration@EnableAutoConfiguration@ComponentScanpublic class SpecialtymallApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpecialtymallApplication.class, args); &#125;&#125; @AutoWired:byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。 1234567@RestControllerpublic class APIUserController &#123; @Autowired private SystemUserService systemUserService;&#125; @Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用 @Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。 @RequestMapping：RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：params:指定request中必须包含某些参数值是，才让该方法处理。headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。value:指定请求的实际地址，指定的地址可以是URI Template 模式method:指定请求的method类型， GET、POST、PUT、DELETE等consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回 12345678910111213@RestControllerpublic class APIUserController &#123; @Autowired private SystemUserService systemUserService; @RequestMapping(value =\"/api/admin/systemUser/create\", method = RequestMethod.POST) public String list(SystemUser systemUser) &#123;// SystemUser systemUsers = systemUserService.insert(systemUser); return JSON.toJSONString(systemUser); &#125;&#125; @RequestParam：用在方法的参数前面。@RequestParam String a =request.getParameter(“a”)。 @PathVariable:路径变量。参数与大括号里的名字一样要相同。 1234RequestMapping(\"user/get/mac/&#123;macAddress&#125;\")public String getByMacAddress(@PathVariable String macAddress)&#123; //do something;&#125; @ProfilesSpring Profiles提供了一种隔离应用程序配置的方式，并让这些配置只能在特定的环境下生效。任何@Component或@Configuration都能被@Profile标记，从而限制加载它的时机。 12345@Configuration@Profile(\"prod\")public class ProductionConfiguration &#123; // ...&#125; @ConfigurationPropertiesSpring Boot将尝试校验外部的配置，默认使用JSR-303（如果在classpath路径中）。你可以轻松的为你的@ConfigurationProperties类添加JSR-303 javax.validation约束注解： 1234567@Component@ConfigurationProperties(prefix=\"connection\")public class ConnectionSettings &#123;@NotNullprivate InetAddress remoteAddress;// ... getters and setters&#125; @ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。 @ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。","categories":[{"name":"spring boot 注解","slug":"spring-boot-注解","permalink":"http://yoursite.com/categories/spring-boot-注解/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"},{"name":"spring-boot","slug":"spring-boot","permalink":"http://yoursite.com/tags/spring-boot/"}]},{"title":"spring","slug":"spring-ioc","date":"2017-12-05T02:17:02.322Z","updated":"2017-12-05T02:17:02.318Z","comments":true,"path":"2017/12/05/spring-ioc/","link":"","permalink":"http://yoursite.com/2017/12/05/spring-ioc/","excerpt":"","text":"spring-ioc spring-aop 控制反转 切面编程 xXx IOCIOC：IOC，另外一种说法叫DI（Dependency Injection），即依赖注入。它并不是一种技术实现，而是一种设计思想。在任何一个有实际开发意义的程序项目中，我们会使用很多类来描述它们特有的功能，并且通过类与类之间的相互协作来完成特定的业务逻辑。这个时候，每个类都需要负责管理与自己有交互的类的引用和依赖，代码将会变的异常难以维护和极度的高耦合。而IOC的出现正是用来解决这个问题，我们通过IOC将这些相互依赖对象的创建、协调工作交给Spring容器去处理，每个对象只需要关注其自身的业务逻辑关系就可以了。在这样的角度上来看，获得依赖的对象的方式，进行了反转，变成了由spring容器控制对象如何获取外部资源（包括其他对象和文件资料等等）。 123举例：某一天，你生病了，但是你不清楚自己到底得了什么病，你只知道自己头疼，咳嗽，全身无力。这个时候你决定去药店买药，药店有很多种药，仅仅是治疗头疼就有好几十种，还有西药中药等区别。然后你自己看了看说明书，选择了一盒你自己觉得最能治疗自己病症的药，付钱吃药，期待可以早点好起来。 但是这个过程，对于一个病人来说，太辛苦了。头疼，咳嗽，全身无力，还要一个个的看药品说明书，一个个的比较哪个药比较好，简直是太累了。这个时候，你决定直接去医院看医生。 医生给你做了检查，知道你的病症是什么，有什么原因引起的；同时医生非常了解有哪些药能治疗你的病痛，并且能根据你的自身情况进行筛选。只需要短短的十几分钟，你就能拿到对症下药的药品，即省时又省力。 在上面这个例子中，IOC起到的就是医生的作用，它收集你的需求要求，并且对症下药，直接把药开给你。你就是对象，药品就是你所需要的外部资源。通过医生，你不用再去找药品，而是通过医生把药品开给你。这就是整个IOC的精髓所在。 aopAOP：面向切面编程，往往被定义为促使软件系统实现关注点的分离的技术。系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。AOP的概念不好像IOC一样实例化举例，现在我们以一个系统中的具体实现来讲讲AOP具体是个什么技术。 1我们以系统中常用到的事务管控举例子。在系统操作数据库的过程中，不可避免地要考虑到事务相关的内容。如果在每一个方法中都新建一个事务管理器，那么无疑是对代码严重的耦合和侵入。为了简化我们的开发过程（实际上spring所做的一切实现都是为了简化开发过程），需要把事务相关的代码抽成出来做为一个独立的模块。通过AOP，确认每一个操作数据库方法为一个连接点，这些连接点组成了一个切面。当程序运行到其中某个一个切点时，我们将事务管理模块顺势织入对象中，通过通知功能，完成整个事务管控的实现。这样一来，所有的操作数据库的方法中不需要再单独关心事务管理的内容，只需要关注自身的业务代码的实现即可。所有的事务管控相关的内容都通过AOP的方式进行了实现。简化了代码的内容，将目标对象复杂的内容进行解耦，分离业务逻辑与横切关注点。 下面介绍一下AOP相关的术语： 通知： 通知定义了切面是什么以及何时使用的概念。Spring 切面可以应用5种类型的通知： 前置通知（Before）：在目标方法被调用之前调用通知功能。后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么。返回通知（After-returning）：在目标方法成功执行之后调用通知。异常通知（After-throwing）：在目标方法抛出异常后调用通知。环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。连接点：是在应用执行过程中能够插入切面的一个点。 切点： 切点定义了切面在何处要织入的一个或者多个连接点。切面：是通知和切点的结合。通知和切点共同定义了切面的全部内容。引入：引入允许我们向现有类添加新方法或属性。织入：是把切面应用到目标对象，并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期中有多个点可以进行织入：编译期： 在目标类编译时，切面被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。类加载期：切面在目标加载到JVM时被织入。这种方式需要特殊的类加载器(class loader)它可以在目标类被引入应用之前增强该目标类的字节码。运行期： 切面在应用运行到某个时刻时被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面的。","categories":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/categories/spring/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"mybatis","slug":"Mybatis_Generator","date":"2017-11-28T07:44:21.172Z","updated":"2017-11-28T07:44:21.168Z","comments":true,"path":"2017/11/28/Mybatis_Generator/","link":"","permalink":"http://yoursite.com/2017/11/28/Mybatis_Generator/","excerpt":"","text":"Mybatis Generator最完整配置详解.xXx Mybatis Generator最完整配置详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;!-- 配置生成器 --&gt;&lt;generatorConfiguration&gt;&lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用$&#123;propertyKey&#125;的方式来引用配置项 resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties. 注意，两个属性只能选址一个; 另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用&lt;properties resource=\"\" url=\"\" /&gt; --&gt; &lt;!-- 在MBG工作的时候，需要额外加载的依赖包 location属性指明加载jar/zip包的全路径&lt;classPathEntry location=\"/Program Files/IBM/SQLLIB/java/db2java.zip\" /&gt; --&gt;&lt;!-- context:生成一组对象的环境 id:必选，上下文id，用于在生成错误时提示 defaultModelType:指定生成对象的样式 --特别说明 我的前面三个都不管用,不知道为啥 1，conditional：类似hierarchical； 2，flat：所有内容（主键，blob）等全部生成在一个对象中； 3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class) targetRuntime: 1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample； 2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample； introspectedColumnImpl：类全限定名，用于扩展MBG--&gt;&lt;context id=\"mysql\" defaultModelType=\"hierarchical\" targetRuntime=\"MyBatis3Simple\" &gt; &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表； 一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖 --&gt; &lt;property name=\"autoDelimitKeywords\" value=\"false\"/&gt; &lt;!-- 生成的Java文件的编码 --&gt; &lt;property name=\"javaFileEncoding\" value=\"UTF-8\"/&gt; &lt;!-- 格式化java代码 --&gt; &lt;property name=\"javaFormatter\" value=\"org.mybatis.generator.api.dom.DefaultJavaFormatter\"/&gt; &lt;!-- 格式化XML代码 --&gt; &lt;property name=\"xmlFormatter\" value=\"org.mybatis.generator.api.dom.DefaultXmlFormatter\"/&gt; &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt; &lt;property name=\"beginningDelimiter\" value=\"`\"/&gt; &lt;property name=\"endingDelimiter\" value=\"`\"/&gt; &lt;!-- 必须要有的，使用这个配置链接数据库 @TODO:是否可以扩展 --&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql:///pss\" userId=\"root\" password=\"admin\"&gt; &lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt; &lt;/jdbcConnection&gt; &lt;!-- java类型处理器 用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl； 注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型； --&gt; &lt;javaTypeResolver type=\"org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl\"&gt; &lt;!-- true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型 false：默认, scale&gt;0;length&gt;18：使用BigDecimal; scale=0;length[10,18]：使用Long； scale=0;length[5,9]：使用Integer； scale=0;length&lt;5：使用Short； --&gt; &lt;property name=\"forceBigDecimals\" value=\"false\"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- java模型创建器，是必须要的元素 负责：1，key类（见context的defaultModelType）；2，java类；3，查询类 targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制； targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录 --&gt; &lt;javaModelGenerator targetPackage=\"com._520it.mybatis.domain\" targetProject=\"src/main/java\"&gt; &lt;!-- for MyBatis3/MyBatis3Simple 自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter； --&gt; &lt;property name=\"constructorBased\" value=\"false\"/&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;!-- for MyBatis3 / MyBatis3Simple 是否创建一个不可变的类，如果为true， 那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类 --&gt; &lt;property name=\"immutable\" value=\"false\"/&gt; &lt;!-- 设置一个根对象， 如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项 注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括： 1，属性名相同，类型相同，有相同的getter/setter方法； --&gt; &lt;property name=\"rootClass\" value=\"com._520it.mybatis.domain.BaseDomain\"/&gt; &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt; &lt;property name=\"trimStrings\" value=\"true\"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成SQL map的XML文件生成器， 注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口）， 或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置 targetPackage/targetProject:同javaModelGenerator --&gt; &lt;sqlMapGenerator targetPackage=\"com._520it.mybatis.mapper\" targetProject=\"src/main/resources\"&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口 targetPackage/targetProject:同javaModelGenerator type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）： 1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML； 2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中； 3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML； 注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER --&gt; &lt;javaClientGenerator targetPackage=\"com._520it.mybatis.mapper\" type=\"ANNOTATEDMAPPER\" targetProject=\"src/main/java\"&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查 &lt;property name=\"rootInterface\" value=\"\"/&gt; --&gt; &lt;/javaClientGenerator&gt; &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素 选择的table会生成一下文件： 1，SQL map文件 2，生成一个主键类； 3，除了BLOB和主键的其他字段的类； 4，包含BLOB的类； 5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选； 6，Mapper接口（可选） tableName（必要）：要生成对象的表名； 注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会 根据设置的schema，catalog或tablename去查询数据表，按照下面的流程： 1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询； 2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找； 3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找； 4，否则，使用指定的大小写格式查询； 另外的，如果在创建表的时候，使用的\"\"把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名； 这个时候，请设置delimitIdentifiers=\"true\"即可保留大小写格式； 可选： 1，schema：数据库的schema； 2，catalog：数据库的catalog； 3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName 4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面； 5，enableInsert（默认true）：指定是否生成insert语句； 6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）； 7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句； 8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)； 9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）； 10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句； 11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）； 12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）； 13，modelType：参考context元素的defaultModelType，相当于覆盖； 14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性） 15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性 注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写； --&gt; &lt;table tableName=\"userinfo\" &gt; &lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt; &lt;property name=\"constructorBased\" value=\"false\"/&gt; &lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt; &lt;property name=\"ignoreQualifiersAtRuntime\" value=\"false\"/&gt; &lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt; &lt;property name=\"immutable\" value=\"false\"/&gt; &lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt; &lt;property name=\"modelOnly\" value=\"false\"/&gt; &lt;!-- 参考 javaModelGenerator 的 rootClass 属性 &lt;property name=\"rootClass\" value=\"\"/&gt; --&gt; &lt;!-- 参考javaClientGenerator 的 rootInterface 属性 &lt;property name=\"rootInterface\" value=\"\"/&gt; --&gt; &lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog &lt;property name=\"runtimeCatalog\" value=\"\"/&gt; --&gt; &lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema &lt;property name=\"runtimeSchema\" value=\"\"/&gt; --&gt; &lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename &lt;property name=\"runtimeTableName\" value=\"\"/&gt; --&gt; &lt;!-- 注意，该属性只针对MyBatis3Simple有用； 如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件； --&gt; &lt;property name=\"selectAllOrderByClause\" value=\"age desc,username asc\"/&gt; &lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt; &lt;property name=\"useActualColumnNames\" value=\"false\"/&gt; &lt;!-- generatedKey用于生成生成主键的方法， 如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选 column:主键的列名； sqlStatement：要生成的selectKey语句，有以下可选项： Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() DB2 :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() DB2_MF :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1 Derby :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL() HSQLDB :相当于selectKey的SQL为：CALL IDENTITY() Informix :相当于selectKey的SQL为：select dbinfo('sqlca.sqlerrd1') from systables where tabid=1 MySql :相当于selectKey的SQL为：SELECT LAST_INSERT_ID() SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY() SYBASE :相当于selectKey的SQL为：SELECT @@IDENTITY JDBC :相当于在生成的insert元素上添加useGeneratedKeys=\"true\"和keyProperty属性 &lt;generatedKey column=\"\" sqlStatement=\"\"/&gt; --&gt; &lt;!-- 该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候， 比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等； 那么就可以设置searchString为\"^CUST_\"，并使用空白替换，那么生成的Customer对象中的属性名称就不是 custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email； 注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的， 如果使用了columnOverride元素，该属性无效； &lt;columnRenamingRule searchString=\"\" replaceString=\"\"/&gt; --&gt; &lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性； column:要重新设置的列名； 注意，一个table元素中可以有多个columnOverride元素哈~ --&gt; &lt;columnOverride column=\"username\"&gt; &lt;!-- 使用property属性来指定列要生成的属性名称 --&gt; &lt;property name=\"property\" value=\"userName\"/&gt; &lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名 &lt;property name=\"javaType\" value=\"\"/&gt; --&gt; &lt;!-- jdbcType用于指定该列的JDBC类型 &lt;property name=\"jdbcType\" value=\"\"/&gt; --&gt; &lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler 只会生成类似：where id = #&#123;id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler&#125;的参数描述 &lt;property name=\"jdbcType\" value=\"\"/&gt; --&gt; &lt;!-- 参考table元素的delimitAllColumns配置，默认为false &lt;property name=\"delimitedColumnName\" value=\"\"/&gt; --&gt; &lt;/columnOverride&gt; &lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现 column:指定要忽略的列的名字； delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false 注意，一个table元素中可以有多个ignoreColumn元素 &lt;ignoreColumn column=\"deptId\" delimitedColumnName=\"\"/&gt; --&gt; &lt;/table&gt;&lt;/context&gt;&lt;/generatorConfiguration&gt;","categories":[{"name":"Mybatis Generator","slug":"Mybatis-Generator","permalink":"http://yoursite.com/categories/Mybatis-Generator/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"正则表达式","slug":"regular_expression","date":"2017-11-28T07:44:21.168Z","updated":"2017-11-28T07:44:21.164Z","comments":true,"path":"2017/11/28/regular_expression/","link":"","permalink":"http://yoursite.com/2017/11/28/regular_expression/","excerpt":"","text":"整理了一下正则,对你会有帮助的!xXx ###基本用法 runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。 runoob，可以匹配 runob、runoob、runoooooob 等， 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。 colou?r 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。","categories":[{"name":"java 正则表达式","slug":"java-正则表达式","permalink":"http://yoursite.com/categories/java-正则表达式/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"SELECT","slug":"select","date":"2017-11-27T10:35:36.463Z","updated":"2017-11-27T10:35:36.459Z","comments":true,"path":"2017/11/27/select/","link":"","permalink":"http://yoursite.com/2017/11/27/select/","excerpt":"","text":"这篇文章主要是做一下Java的查询算法的整理,xXx 二分法查找1234567891011121314151617int BinarySearch1(int a[], int value, int n)&#123; int low, high, mid; low = 0; high = n-1; while(low&lt;=high) &#123; mid = (low+high)/2; if(a[mid]==value) return mid; if(a[mid]&gt;value) high = mid-1; if(a[mid]&lt;value) low = mid+1; &#125; return -1;&#125; 二分法查找(递归)12345678910int BinarySearch2(int a[], int value, int low, int high)&#123; int mid = low+(high-low)/2; if(a[mid]==value) return mid; if(a[mid]&gt;value) return BinarySearch2(a, value, low, mid-1); if(a[mid]&lt;value) return BinarySearch2(a, value, mid+1, high);&#125;","categories":[{"name":"java SE","slug":"java-SE","permalink":"http://yoursite.com/categories/java-SE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-11-27T09:04:07.991Z","updated":"2017-11-27T09:04:07.991Z","comments":true,"path":"2017/11/27/hello-world/","link":"","permalink":"http://yoursite.com/2017/11/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.xXx Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo教程","slug":"Hexo教程","permalink":"http://yoursite.com/categories/Hexo教程/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"SORT","slug":"sort","date":"2017-11-27T08:53:13.215Z","updated":"2017-11-27T08:53:13.215Z","comments":true,"path":"2017/11/27/sort/","link":"","permalink":"http://yoursite.com/2017/11/27/sort/","excerpt":"","text":"这篇文章主要是做一下Java的排序算法的整理,xXx 冒泡排序1234567891011121314151617181920212223242526/* * 冒泡排序 */public class BubbleSort &#123; public static void main(String[] args) &#123; int[] arr=&#123;6,3,8,2,9,1&#125;; System.out.println(\"排序前数组为：\"); for(int num:arr)&#123; System.out.print(num+\" \"); &#125; for(int i=0;i&lt;arr.length-1;i++)&#123;//外层循环控制排序趟数 for(int j=0;j&lt;arr.length-1-i;j++)&#123;//内层循环控制每一趟排序多少次 if(arr[j]&gt;arr[j+1])&#123; int temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125; System.out.println(); System.out.println(\"排序后的数组为：\"); for(int num:arr)&#123; System.out.print(num+\" \"); &#125; &#125; &#125; 插入式排序1234567891011121314151617181920public class InsertSort &#123; public static void insertSort(int[] a) &#123; int i, j, insertNote;// 要插入的数据 for (i = 1; i &lt; a.length; i++) &#123;// 从数组的第二个元素开始循环将数组中的元素插入 insertNote = a[i];// 设置数组中的第2个元素为第一次循环要插入的数据 j = i - 1; while (j &gt;= 0 &amp;&amp; insertNote &lt; a[j]) &#123; a[j + 1] = a[j];// 如果要插入的元素小于第j个元素,就将第j个元素向后移动 j--; &#125; a[j + 1] = insertNote;// 直到要插入的元素不小于第j个元素,将insertNote插入到数组中 &#125; &#125; public static void main(String[] args) &#123; int a[] = &#123; 38,65,97,76,13,27,49 &#125;; insertSort(a); System.out.println(Arrays.toString(a)); &#125;&#125; 选择排序12345678910111213141516171819202122232425262728public class SelectionSort &#123; public static void selectionSort(int[] a) &#123; int n = a.length; for (int i = 0; i &lt; n; i++) &#123; int k = i; // 找出最小值的小标 for (int j = i + 1; j &lt; n; j++) &#123; if (a[j] &lt; a[k]) &#123; k = j; &#125; &#125; // 将最小值放到排序序列末尾 if (k &gt; i) &#123; int tmp = a[i]; a[i] = a[k]; a[k] = tmp; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] b = &#123; 49, 38, 65, 97, 76, 13, 27, 50 &#125;; selectionSort(b); for (int i : b) System.out.print(i + \" \"); &#125;&#125; 快速排序123456789101112public void listSort1()&#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(55); list.add(9); list.add(0); list.add(2); Collections.sort(list);//使用Collections的sort方法 for(int a :list)&#123; System.out.println(a); &#125;&#125;","categories":[{"name":"java SE","slug":"java-SE","permalink":"http://yoursite.com/categories/java-SE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]}]}